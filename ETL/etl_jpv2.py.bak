#coding: utf-8
from pymongo import MongoClient
from pymongo.collection import Collection
import json

# Create your views here.

def get_user_connection(user_id):
    connection = {}
    connection['client'] = MongoClient()

    user_db_name = "infosync_answers_client_{0}".format(user_id) 

    if not user_db_name:
        return None
    connection['db'] = connection['client'][user_db_name]   

    return connection

class FakeETLModel(object):
    def __init__(self, **kwargs):
        self.name = kwargs["name"]
        #rtype = kwarghs["rtype"]
        self.item_id = kwargs["item_id"]
        self.filters = kwargs["filters"]
        self.user_id = kwargs["user_id"]
        #created_at = kwargs["created_at"]
        #updated_at = kwargs["updated_at"]
        #expiration = kwargs["expiration"]
        #active = True

def get_answer(answers, field):
    # Formatear respuesta dependiendo del tipo de campo
    field_id = field["field_id"]["id"]
    answer = answers.get(field_id)
    # Imagen, Documento, Firma
    if field["field_type"] in ["geolocation", "signature", "image", "document"]:
        return None
    # Opcion multiple
    elif field["field_type"] in ["checkbox"]:
        options = {}
        for option in field["options"]:
            options[option["value"]] = option["label"]
        for value in answer:
            if options.get(value):
                return options[value]
            else:
                return value
    # Radio
    elif field["field_type"] == "radio":
            options = {}
            for option in field["options"]:
                options[option["value"]] = option["label"]
            if options.get(answer):
                return options.get(answer)
            else:
                return answer
    # Demás tipos
    else:
        return answer

def get_newanswer():

def etl():
    # Repetir para cada modelo en la tabla de reportes
    #item = Item.objects.get(id=524)
    #items_to_search  = [516,517,549,554,2119]
    items_to_search = [2119,]
    types = open("tipos.json", "r")
    types_dictionary = json.loads(types.read())
    for item in items_to_search:
	print 'working on item', item
        # Modelo para pruebas
        print 'item=', item
        etl_model = FakeETLModel(
        **{
            'name': 'Reporte', 'item_id':  item, 'user_id': 94,
            'filters': ['Fraccionamiento', 'Manzana', 'Lote', 'Concepto']
            }
        )

        user_conn = get_user_connection(etl_model.user_id)
        # Form answer collection
        form_answer = user_conn['db']['form_answer']

        # Obtener coleccion de reportes si existe, crear si aún no existe
        if 'report_answer_g' in user_conn['db'].collection_names():
            report_answer = user_conn['db']['report_answer_g']
        else:
            report_answer = Collection(user_conn['db'], "report_answer_g", create=True)

        # Plantilla del reporte
        report = { "form_id": etl_model.item_id, "answers": [] }
        # Recorrer todos los registros de la forma
        for record in form_answer.find({"form_id": etl_model.item_id}):
            # Diccionario para obtener campos dado su id
            fields = {}
            # Diccionario para obtener campos dado su label (para filtros)
            filter_fields = {}
            for page in record["voucher"]["form_pages"]:
                for field in page["page_fields"]:
                    field["page"] = page["page_name"]
                    fields[field["field_id"]["id"]] = field
                    if field['label'] in etl_model.filters:
                        filter_fields[field["label"]] = field   
            tmp_filters = {}
            for filter_id in etl_model.filters:
		print 'filter ', filter_id
		try:
                	tmp_filters[filter_id] = get_answer(record["answers"], fields[filter_fields[filter_id]["field_id"]["id"]])
		except KeyError:
			pass
            # Recorrer cada respuesta
            for field_id in record["answers"]:
		print 'field type', fields[field_id]["field_type"]
		field_type = fields[field_id]["field_type"]
                answer = record["answers"][field_id]
                #field = fields[field_id]
                #if fields["field_type"] in ["radio"]: print 'radio'
                # METADATA
                new_answer = {
                "field_id": field_id,
                "page_name": fields[field_id]["page"],
                "field_type": field_type, #fields[field_id]["field_type"],
                "field_text": fields[field_id]["label"],
                "tipo": types_dictionary.get(field_id, None)
                }
                meta = ["browser", "created_at", "updated_at", "end_date", "ip", "platform", "start_date"]
                for key in meta:
                    new_answer[key] = record.get(key)

                # Añadir valores de filtros (si todos fueron contestados)
                #if all(tmp_filters.values()):
                #new_answer.update(tmp_filters)
                for key in tmp_filters:
                    print 'llave', key
                    if key in ['Manzana','Lote']:
                        value = int(tmp_filters[key])
                        new_answer[key.lower()] = '%02d'%value
                    else:
                        new_answer[key.lower()] = tmp_filters[key]

                new_answer["field_value"] = get_answer(record["answers"], fields[field_id])
		print 'new answer',new_answer
                report["answers"].append(new_answer)
        # Editar reporte si existe, crear si no es así
        if report_answer.find({"form_id": etl_model.item_id}).count() > 0:
            report_answer.update({"form_id": etl_model.item_id}, report)
        else:
            report_answer.insert(report)
etl()

